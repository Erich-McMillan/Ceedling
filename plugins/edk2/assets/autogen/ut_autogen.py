# Â© Copyright 2019-2020 HP Development Company, L.P.
# SPDX-License-Identifier: MIT

import os
import argparse
from inf_parser import inf_parser
from pcd_parser import *
from configparser import NoSectionError
from guidlib import GuidLib
from PathClass import PathClass
import GenC

# move to separate file
TAB_PCDS = 'Pcds'
TAB_PCDS_FIXED_AT_BUILD = 'FixedAtBuild'
TAB_PCDS_PATCHABLE_IN_MODULE = 'PatchableInModule'
TAB_PCDS_FEATURE_FLAG = 'FeatureFlag'
TAB_PCDS_DYNAMIC_EX = 'DynamicEx'
TAB_PCDS_DYNAMIC_EX_DEFAULT = 'DynamicExDefault'
TAB_PCDS_DYNAMIC_EX_VPD = 'DynamicExVpd'
TAB_PCDS_DYNAMIC_EX_HII = 'DynamicExHii'
TAB_PCDS_DYNAMIC = 'Dynamic'
TAB_PCDS_DYNAMIC_DEFAULT = 'DynamicDefault'
TAB_PCDS_DYNAMIC_VPD = 'DynamicVpd'
TAB_PCDS_DYNAMIC_HII = 'DynamicHii'

class Library():
    def __init__():
        self.ConstructorList = []
class Module:
    def __init__(self):
        self.ModuleType = ''
        self.ConstructorList = []
        self.DestructorList = []
        self.ModuleEntryPointList = []
        self.ModuleUnloadImageList = []
        self.LibraryClasses = dict() # probably don't care in unit tests
        self.Pcds = [] # probably don't care in unit tests
        self.Specification = "" # UEFI_SPECIFICATION_VERSION, or PI_SPECIFICATION_VERSION, we can leave this blank since we don't care in ut
        self.Guids = []

    def GetGuidsUsedByPcd(self):
        # return null because we don't care about other packages...
        return []


class Platform:
    def __init__(self):
        self.RFCLanguages = []
        self.ISOLanguages = []

class PlatformInfo:
    def __init__(self):
        self.Platform = Platform()
        self.PcdTokenNumber = dict()

class AutoGenInfo:
    def __init__(self):
        self.Name = '' # name of driver or library from inf
        self.Guid = '' # guid of driver of library from inf
        self.AutoGenVersion = None
        self.MetaFile = None
        self.Module = Module()
        self.ModuleType = '' # type of module UEFI_DRIVER, DXE_DRIVER, etc from inf
        self.GuidList = dict() # list of guids from inf guid section
        self.IsLibrary = False # whether or not this is a library or driver
        self.PcdIsDriver = ""
        self.DependentLibraryList = [] # list of dependent libraries of type Library probably not needed
        self.PpiList = []
        self.ModulePcdList = []
        self.LibraryPcdList = []
        self.ProtocolList = []
        self.SourceFileList = []
        self.UnicodeFileList = []
        self.WorkspaceDir = None
        self.PlatformInfo = PlatformInfo()
        self.IncludePathList = []

def splitsourceandunifiles(allFiles):
    unis = []
    source = []
    for f in allFiles:
        spt = str(f).split('.')
        if str(f).split('.')[1] == 'uni':
            unis.append(f)
        else:
            source.append(f)

    return (source, unis)


def main():
    parser = argparse.ArgumentParser(description='Create autogen.c/h for Ceedling unit tests from a module inf or package dsc.')
    parser.add_argument('infpath', help='Path to the inf file to autogenerate binding files for.')
    parser.add_argument('outputdir', help='Directory to place autogenerated files.')
    args = parser.parse_args()

    print("Starting to autogen for {0}".format(args.infpath))
    info = AutoGenInfo()
    guidlib = GuidLib()
    parse = inf_parser(args.infpath)

    info.WorkspaceDir = os.path.dirname(args.infpath)
    # Just use current path, no code actually looks at the project DSC or uses this path directly, but this metafile path must be valid.
    info.MetaFile = PathClass(File=os.path.abspath("."))

    # get defines0
    try:
        defines = parse.parse_defines()
    except NoSectionError:
        raise NoSectionError('ERROR: {0} does not have a [Defines] section. Exiting autogen.')
    info.Name = defines['BASE_NAME']
    info.Guid = defines['FILE_GUID']
    info.AutoGenVersion = defines['INF_VERSION']
    info.ModuleType = defines['MODULE_TYPE']
    info.IsLibrary = defines.get('LIBRARY_CLASS', fallback=False)
    if defines.get('ENTRY_POINT', fallback=None) is not None:
        info.Module.ModuleEntryPointList.append(defines['ENTRY_POINT'])

    # get library classes
    ## not needed for unit tests so far...

    # get source and uni files
    try:
        info.SourceFileList, info.UnicodeFileList = splitsourceandunifiles(parse.parse_sources())
    except NoSectionError:
        # Source files are not necessary to create autogen files, but probably should through here,
        # since source files are needed for unit tests
        pass

    temp = []
    for uni in info.UnicodeFileList:
        temp.append(PathClass(File=os.path.abspath(os.path.join(info.WorkspaceDir, uni))))
    info.UnicodeFileList = temp
    temp = []
    for src in info.SourceFileList:
        temp.append(PathClass(File=os.path.abspath(os.path.join(info.WorkspaceDir, src))))
    info.SourceFileList = temp

    # get guids
    try:
        info.GuidList = parse.parse_guids()
        info.Module.Guids = info.GuidList
    except NoSectionError:
        # Guids are not necessary to create autogen files
        pass

    # get protocols
    try:
        info.ProtocolList = parse.parse_protocols()
    except NoSectionError:
        # protocols are not necessary to create autogen files
        pass

    # get pcds
    rawPcds = []
    try:
        rawPcds = parse.parse_pcds()
    except NoSectionError:
        # pcds are not necessary to create autogenfiles
        pass

    purePcds = []
    for rawPcd in rawPcds:
        purePcds.append(pcd(rawPcd))

    pcd_parser.process_pcds(info.SourceFileList, purePcds)

    info.ModulePcdList = purePcds
    TokenNumber = 1
    for processedPcd in purePcds:
        info.PlatformInfo.PcdTokenNumber[processedPcd.TokenCName, processedPcd.TokenSpaceGuidCName] = TokenNumber
        TokenNumber += 1
    info.Module.Pcds = info.ModulePcdList

    # get ppis
    try:
        info.PpiList = parse.parse_ppis()
    except NoSectionError:
        # ppis are not necessary to create autogenfiles
        pass

    # generate code
    GenC.CreateCode(info, args.outputdir)


if __name__ == "__main__":
    main()
